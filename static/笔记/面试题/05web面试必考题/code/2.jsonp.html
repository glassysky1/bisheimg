<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <!-- <tr><td>{$id}</td><td>{$id}_{$name}</td></tr> -->
  <script>
    // var url = 'http://item.taobao.com/item.htm?a=1&b=2&c=xxx'
    // var str = url.substr(url.indexOf('?')+1)
    // var arr = str.split('&')
    // var obj = {}

    // for(var i =0;i<arr.length;i++){
    //   var arri = arr[i]
    //   var i2 = arri.split('=')
    //   obj[i2[0]] = i2[1]
    // }
    // console.log(obj)

    // function fn() {
    //   console.log(arguments.callee == fn)//true
    //   console.log(fn.caller)//指向fn2，自己单独调用时是null

    // }
    // function fn2() {
    //   fn()
    // }
    // fn2()

    // var arr = new Array(1, 3, 5)
    // arr[4] = 'z'
    // arr2 = arr.reverse() // arr2=['z',undefined,5,3,1]
    //                     //arr = ['z',undefined,5,3,1]
    // arr3=arr.concat(arr2)
    // console.log(arr3)
    // //考点:reverse方法颠倒数组中元素的位置，并返回该数组的引用

    // //第一种(函数声明)
    // function sum1(num1,num2) {
    //   return num1 + num2
    // }
    // //第二种(函数表达式)
    // var sum2 = function (num1,num2) {
    //   return num1 + num2
    // }
    // //第三种 (函数对象方式)了解
    // var sum3 = new Function('num1','num2',"return num1 + num2")

    // function f1() {
    //   var tmp = 1
    //   this.x = 3
    //   console.log(tmp)
    //   console.log(this.x)
    // }
    // var obj = new f1() //1 3
    // console.log(obj.x)//3
    // console.log(f1()) //1 3 undefined


    // function changeObjectProperty(o) {
    //   o.siteUrl = 'http://www.csser.com/'
    //   o = new Object()
    //   o.siteUrl = 'http://www.popcg.com'
    // }

    // var CSSer = new Object()
    // changeObjectProperty(CSSer)
    // console.log(CSSer.siteUrl)


    // var a = 6
    // setTimeout(function () {
    //   var a = 666 //由于变量a是一个局部变量
    //   console.log(a)
    //   //输出666
    // });
    // a = 66
    // console.log(a)
    // /* 
    // 先打印全局变量a的值：66，再执行setTimeout里面的局部变量
    // 因为var a = 666定义了局部变量a，并赋值为666，根据变量作用域链，
    // 全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量
    // //  */

    // window.color = 'red'
    // var o = {color:'blue'}
    // function sayColor() {
    //   console.log(this.color)
    // }
    // sayColor()//red
    // sayColor.call(this)//red this指向的是window对象
    // sayColor.call(window)//red
    // sayColor.call(o)//blue

    // function foo() {
    //   foo.a = function () {console.log(1)}
    //   this.a = function () {console.log(2)}//obj.a()
    //   a = function () {console.log(3)}
    //   var a = function () {console.log(4)}
    // }
    // foo.prototype.a = function () {console.log(5)}
    // foo.a = function () { console.log(6) }
    // foo.a()//6
    // var obj = new foo()
    // obj.a()//2 先查找构造函数，在找原型对象里的
    // foo.a()//1

    // var a = 5
    // function test() {
    //   a = 0
    //   console.log(a)
    //   console.log(this.a)//this指向window
    //   var a //现在当前作用域作变量提升
    //   console.log(a)
    // }
    // test()//0 5 0
    // new test()// 0,undefined,0//由于类它自身没有属性a，所以是undefined

    // var bool = !!2 
    // console.log(bool)
    
      // //call方法
      // function Parent(name,money) {
      //   this.name = name
      //   this.money = money
      //   this.info=function () {
      //     console.log('香茗'+this.name+'钱：'+this.money)
      //   }
      // }

      // //定义孩子类
      // function Children(name) {
      //   Parent.call(this,name)//继承 姓名属性 ，不要钱
      //   this.info = function () {
      //     console.log('姓名'+this.name)
      //   }
      // }
      var foo = '11'+2-'1'
      console.log(foo)
      console.log(typeof foo)//number
      
      
  </script>
</body>

</html>