<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <!-- <button id="btn">点击我</button>
  <script>
  var btn = document.getElementById('btn')
  var handle ={
    id:'eventHandle',
    exec:function(){
      console.log(this.id)
    }
  }
  btn.addEventListener('click',handle.exec)//btn
  </script> -->

  <script>
    /*     var obj = {
          proto: {
            a: 1,
            b: 2
          }
        }
        function F(){}
        F.prototype = obj.proto
        var f= new F()
        obj.proto.c=3
        obj.proto = {a:-1,b:-2}//直接改引用(地址)了，但是F.prototype引用(地址)没变
        console.log(f.a)//1
        console.log(f.c)//3
        delete F.prototype['a']
        console.log(f.a)//undefined
        console.log(obj.proto.a)//-1 */

    // if (!String.prototype.trim) {
    //   String.prototype.trim = function () {
    //     return this.replace(/^\s+/,'').replace(/\s+$/,'')
    //   }
    // }

    /*     var b =2
        function test2() {
          window.b =3
          console.log(b)
        }
        test2()//3 */

  //  c = 5//声明一个全局变量
  //   function test3() {
  //     window.c=3
  //     console.log(c)//答案：undefined，由于此时的c是一个局部变量c，并且没有被赋值
  //     var c 
  //     console.log(window.c)//答案：3原因：这里的c就是一个全局变量c
  //   }
  //   test3()


/*   var arr = []
  arr[0] = 'a'
  arr[1] = 'b'
  arr[10] = 'c'
  console.log(arr.length)//1
  console.log(arr[5])//undefined
  
   */

   /* console.log(null==undefined)//true
   console.log('1'==1)//true,因为会将数字1先转换为字符串1
   console.log('1'===1) //false，因为数据类型不一致
    */
/* 
    parseInt(3.14)//3
    parseFloat('3asdf')//3
    parseInt('1,23abdc456')
    parseInt(true) // 'true'=>NaN
 */


/*  //函数声明提前
  function bar() {
    return foo
    foo=10
    function foo(){}
  }
  console.log(typeof bar)//function */

/*   var foo = 1
  function bar() {
    foo = 10
    return
    function foo(){}//相当于var foo = function(){},var foo 要变量提升
  }
  bar()
  console.log(foo)//答案：1 */


/*   console.log(a)//函数
  var a = 3
  function a(){}//相当于 var a = function(){},整个都提升到上面
  console.log(a)//3 */

/*   //对arguments的操作
  function foo(a) {
    arguments[0] = 2
    console.log(a)//答案：2，因为：a、arguments是度实参的访问 b、通过arguments[i]可以修改指定实参的值
  }
  foo(1) */


/*   function foo(a) {
    console.log(arguments.length)//3,因为arguments是对实参的访问
  }
  foo(1,2,3) */

/*   // bar()//报错
  var foo = function bar(name) {
    console.log('hello'+name)
    console.log(bar)
  }
  foo('world')//'helloworld',函数
  // console.log(bar)//undefined
  console.log(foo.toString())//函数
  bar()//报错，报错就是不执行了 */

  var xhr = null//创建对象
  if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest()
  }else{
    xhr = new ActiveXObject('MicrosoftXMLHTTP')
  }
  xhr.open('方式','地址','标志位')//初始化请求
  xhr.setRequestHeader()//设置http头信息
  xhr.onreadystatechange = function () {//指定回调函数
  }
  xhr.send()//发送请求
  </script>
</body>

</html>