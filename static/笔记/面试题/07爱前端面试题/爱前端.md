# this

## this是什么 ？

面试题:this是什么?到底this表达了什么？为什么要有this这个东西?

先看一个例子

```javascript
    var xiaoming ={
      shuxue :50,
      yuwen:89,
      yingyu:10
    }

    function calcTotalScore(o) {
      return o.shuxue +o.yuwen +o.yingyu
    }

    var TotalScore = calcTotalScore(xiaoming)
    alert(TotalScore)
//对象被当做了参数传入了函数的内部。函数从外面接收信息，主要主要依靠参数
```

不依靠参数，函数能不能从外部获取信息？？答案是上下文，**上下文是使信息进入函数内部的一种手段**



现在，我们改变了一下写法，函数没有参数了，现在信息可以通过this这个词语进入到函数的内部

this是函数的上下文。所以说，函数的上下文，是除了参数之外的，**最常用的进入函数内部的手段**

```javascript
    var xiaoming ={
      shuxue :50,
      yuwen:89,
      yingyu:10,
      calcTotalScore:calcTotalScore
    }

    function calcTotalScore() {
      return this.shuxue +this.yuwen +this.yingyu
    }

    //上下文的规则2：对象打点，函数的this是这个对象
   var score =  xiaoming.calcTotalScore()
   alert(score)
```

## this怎么判断？

一定要死记:**function定义的函数，this是什么，要看如何调用，而不是看如何定义**

调用方式决定了this

```javascript
    var obj ={
      a:3,
      b:4,
      fn(){
        alert(this.a)
      }
    }
    var a = 8
    //把函数提出来，存入变量
    var f = obj.fn
    //直接用圆括号调用，上下文是window
    f()

    obj.fn()//上下文是obj
```

函数没有调用的时候，不知道this是谁

## 7个this判断规则

规则1：函数直接用圆括号运行，上下文是window对象

```javascript
fn()  上下文是window
```

```javascript
    var obj = {
      a:3,
      b:4,
      fun:function () {
        var a = 5
        return function () {
          alert(this.a)
        }
      }
    }
    var a =7
    //现在适用规则1：函数直接加圆括号运行了。上下文是window
    obj.fun()()//7
```



规则2：对象打点调用函数，上下文是这个对象

```javascript
obj.fn()   上下文是对象
```

```javascript
    var obj = {
      a:3,
      b:4,
      fun:(function () {
        var a = 5
        return function () {
          alert(this.a)
        }
      })()
    }
    var a =7
    //现在适用规则2：对象打点调用函数。上下文是对象
    obj.fun()//3
```

规则3：数组（类数组对象）中枚举出函数，上下文是这个数组(类数组对象)

```javascript
arr[idx]()	上下文是arr
```

```javascript
    function fun1(fn) {
      //规则3：类数组对象中枚举出函数，然后运行，上下文是这个类数组对象
      arguments[0](3,4)
    }

    function fun2() {
      //fun2函数里面的this居然是fun1的实际参数列表
      //实参长度是5
      alert(this.length)
      alert(arguments.length)//2
    }
    fun1(fun2, 5, 6, 7, 8) //弹出5
```

规则4：定时器调用函数，上下文是window

规则5：被当做了事件处理函数，上下文是触发事件的dom元素

规则6：用new调用函数，上下文是 函数体内秘密创建的空白对象

用new调用函数会经过4步走：

1. 秘密创建空对象
2. 将this绑定到这个空对象中
3. 执行语句
4. 返回这个对象

规则7：用apply、call执行上下文

```javascript
fn.apply(obj,[arg1,arg2])
```

```javascript
fn.call(obj,arg1,arg2)
```

# 面试题举例

```javascript
    function Foo() {
      function getName() {
        alert(1)
      }
      return this
    }
    Foo.getName = function () {
      alert(2)
    }

    Foo.prototype.getName = function () {
      alert(3)
    }
    //定义提升，把函数getName给干掉了
    var getName = function () {
      alert(4)
    }

    //函数优先提升  在最上面
    function getName() {
      alert(5)
    }

    //弹出4
    getName()

    //规则1：函数直接运行上下文是window对象
    //相当于window.getName()
    Foo().getName()

    //考点：原型链查找，对象能够沿原型链，访问自己构造函数prototype上的属性、方法
    new Foo().getName()//3

    //Foo.getName()不是构造函数，是普通函数，人家就爱用new来调用，脑子有坑，你 管他呢
    new Foo.getName()//2


    //写在原型身上的函数，也不是构造函数，是普通函数
    new new Foo().getName()//3
```

```javascript
    function getLength() {
      //上下文是什么实际上在读题的时候，是不知道的，所以千万不要 激动
      return this.length
    }

    function foo() {
      this.length = 1
      return (function () {
        var length = 2
        return {
          length: function (a, b, c) {
            return this.arr.length
          },
          arr: [1, 2, 3, 4],
          info: function () {
            //以this.length作为上下文调用getLength函数
            return getLength.call(this.length)
          }
        }
      })()
    }
    //foo()用规则1,：圆括号直接打点调用函数，所以上下文是window
    //对象.info()用规则2:对象打点调用函数，上下文是这个对象
    //记住：函数的length是形参列表的长度，arguments.length是实参列表的长度
    //arguments.callee表示函数本身，arguments.callee.length也是形参列表的长度
    var result = foo().info()
    alert(result)//3
```

```javascript

    function fun() {
      var a = 1
      this.a = 2
      function fn() {
        return this.a
      }
      fn.a= 3
      return fn
    }

    alert(fun()())//2
```

```javascript
    function fun() {}
    console.log(typeof fun)//function
    console.log(fun instanceof Function)//true
    console.log(fun instanceof Object)//true
```

```javascript
    var a = 1
    var obj = {
      a:2,
      getA:function(){
        return this.a
      }
    }
    var getA = obj.getA
    getA()//1
```

```javascript

    var obj = {
      a:1,
      b:2,
      c:[{
        a:3,
        b:4,
        c:fn
      }]
    }
    function fun() {
      alert(this.a)
    }
    var a = 5
    abj.c[0].c()//3
```

```javascript

    function getLength() {
      alert(arguments.length)
    }

    var arr = [1,2,3,4,5,6]
    //写一条语句弹出6

    getLength.apply(null,arr)
    getLength(...arr)
```

```javascript
    var number = 2
    var obj = {
      number: 4,
      fn1: (function () {//立即执行
        this.number *= 2
        number = number * 2//变量提升，白写了
        var number = 3
        return function () {
          this.number *= 2
          number *= 3
          console.log(number)
        }
      })()
    }

    console.log(number)//4 obj里面的fn1是立即执行函数,相当于在window下的fn1，把fn1里面执行一遍
    var fn1 =  obj.fn1
    fn1()
    obj.fn1()//9 27闭包
    console.log(window.number)//8
    console.log(obj.number)//8
```

